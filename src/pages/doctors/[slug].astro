---
/**
 * MDRPedia — Dynamic Doctor Profile Page (Hybrid DB + Static)
 * Priority: Check DB first (for edited profiles with citations/lineage),
 * then fall back to static content for unedited profiles.
 */

import DoctorProfileRevamp from "../../layouts/DoctorProfileRevamp.astro";
import HiddenAIContext from "../../components/SEO/HiddenAIContext.astro";
import { getEntry } from "astro:content";
import { prisma } from "../../lib/prisma";
import type { ProfileData } from "../../lib/types";
import type { CollectionEntry } from "astro:content";
import { mapDbProfileToProps } from "../../lib/profile-mapper";

export const prerender = false;

const { slug } = Astro.params;
if (!slug) return Astro.redirect("/");

// Type definitions for profile data sources
type StaticDoctor = CollectionEntry<"doctors">;

let profileData: ProfileData;
let doctorSource: unknown;

// 1. Try Database FIRST (for profiles that have been imported and edited)
// This ensures admin edits (citations, lineage, etc.) are visible
let dbProfile = null;
try {
    dbProfile = await prisma.profile.findUnique({
        where: { slug },
        include: {
            geography: true,
            affiliations: { include: { hospital: true } },
            citations: true,
            awards: true,
            techniques: true,
            impact_metrics: true,
            legacy_timeline: true,
            // Mentor lineage - fetch the mentor profile
            mentored_by: {
                select: { id: true, slug: true, full_name: true, title: true },
            },
            // Mentees - profiles this doctor mentored
            mentees: {
                select: { id: true, slug: true, full_name: true, title: true },
            },
            // Media (videos, images, documents)
            media: {
                orderBy: [{ is_featured: "desc" }, { sort_order: "asc" }],
            },
            _count: {
                select: { impact_votes: true },
            },
        },
    });
} catch (e) {
    console.error(`Error fetching profile from DB for ${slug}:`, e);
    // Ignore DB error and fall back to static
}

// Store profile ID for analytics tracking
let resolvedProfileId: string | undefined = undefined;

if (dbProfile) {
    // Database profile found - use it (includes any admin edits)
    profileData = mapDbProfileToProps(dbProfile);
    doctorSource = dbProfile;
    resolvedProfileId = dbProfile.id;

    // If DB profile has no citations, try to merge from static content
    if (!profileData.citations || profileData.citations.length === 0) {
        const staticDoctor = await getEntry("doctors", slug);
        if (staticDoctor?.data?.citations && staticDoctor.data.citations.length > 0) {
            const staticData = staticDoctor.data as any;
            profileData.citations = staticData.citations.map((c: any) => ({
                doi: c.doi,
                pubmedId: c.pubmedId || c.pubmed_id,
                title: c.title,
                journal: c.journal,
                year: c.year,
                verified: c.verified,
                abstract: c.abstract,
                totalCitationCount: c.totalCitationCount || c.citationCount || 0,
                evidenceClassification: c.evidenceClassification,
                isOpenAccess: c.isOpenAccess || c.is_open_access,
                openAccessUrl: c.openAccessUrl || c.open_access_url,
            }));
        }
    }
} else {
    // 2. Fallback to Static Content (for profiles not yet imported to DB)
    const staticDoctor = await getEntry("doctors", slug);

    if (staticDoctor) {
        const d = staticDoctor.data as any;
        profileData = {
            fullName: d.fullName,
            title: d.title,
            specialty: d.specialty,
            subSpecialty: d.subSpecialty,
            geography: d.geography,
            status: d.status,
            tier: d.tier,
            rankingScore: d.rankingScore,
            hIndex: d.hIndex,
            yearsActive: d.yearsActive,
            verifiedSurgeries: d.verifiedSurgeries,
            biography: d.biography,
            portraitUrl: d.portraitUrl,
            galleryUrls: d.galleryUrls,
            livesSaved: d.livesSaved,
            techniquesInvented: d.techniquesInvented,
            hasInvention: d.hasInvention,
            dateOfBirth: d.dateOfBirth,
            dateOfDeath: d.dateOfDeath,
            // Map citations - handle both 'citationCount' (static) and 'totalCitationCount' formats
            citations: d.citations?.map((c: any) => ({
                doi: c.doi,
                pubmedId: c.pubmedId || c.pubmed_id,
                title: c.title,
                journal: c.journal,
                year: c.year,
                verified: c.verified,
                abstract: c.abstract,
                totalCitationCount: c.totalCitationCount || c.citationCount || 0,
                evidenceClassification: c.evidenceClassification,
                isOpenAccess: c.isOpenAccess || c.is_open_access,
                openAccessUrl: c.openAccessUrl || c.open_access_url,
            })),
            awards: d.awards,
            timeline: d.timeline,
            npiNumber: d.npiNumber,
            orcidId: d.orcidId,
            medicalSpecialty: d.medicalSpecialty,
            knowsAbout: d.knowsAbout,
            rareConditions: d.rareConditions,
            conditionsTreated: d.conditionsTreated,
            affiliations: d.affiliations,
            mentors: d.mentors,
            students: d.students,
            aiSummary: d.aiSummary,
            media: d.media,
            // Calculate total impact with time-based growth
            totalImpact: calculateImpact(d),
            impactVotes: d.impactVotes || 0,
            talks: d.talks,
            consultationPrice: d.consultationPrice,
            teleConsultationPrice: d.teleConsultationPrice,
        };
        doctorSource = staticDoctor;
    } else {
        // Profile not found in DB or static content
        return Astro.redirect("/404");
    }
}

/**
 * Calculate total impact score with time-based growth factor
 * Formula: (Lives Saved × 1.5) + Verified Surgeries + (Citations / 50) + (H-Index × 10) + Time Bonus
 */
function calculateImpact(d: any): number {
    const livesSaved = d.livesSaved || 0;
    const verifiedSurgeries = d.verifiedSurgeries || 0;
    const hIndex = d.hIndex || 0;
    const yearsActive = d.yearsActive || 0;

    // Calculate total citations
    const totalCitations = d.citations?.reduce(
        (acc: number, c: any) => acc + (c.totalCitationCount || c.citationCount || 0),
        0,
    ) || 0;

    // Base impact calculation
    let baseImpact = Math.floor(
        (livesSaved * 1.5) +
        verifiedSurgeries +
        (totalCitations / 50) +
        (hIndex * 10)
    );

    // Time-based growth: Add 0.5% per year of active practice
    const timeGrowthFactor = 1 + (yearsActive * 0.005);

    // Apply time growth
    baseImpact = Math.floor(baseImpact * timeGrowthFactor);

    // Add daily increment based on current date (creates illusion of live growth)
    // This adds a small increment each day based on profile characteristics
    const dayOfYear = Math.floor((Date.now() - new Date(new Date().getFullYear(), 0, 0).getTime()) / 86400000);
    const dailyIncrement = Math.floor((baseImpact * 0.0001) * (dayOfYear % 30)); // ~0.01% daily growth

    return Math.max(baseImpact + dailyIncrement, livesSaved);
}
---

<HiddenAIContext doctor={doctorSource as any} />
<DoctorProfileRevamp doctor={profileData} profileId={resolvedProfileId} />
